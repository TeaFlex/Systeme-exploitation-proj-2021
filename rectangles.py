import numpy as np
from sympy import lambdify, Symbol
from utils.derivate import derivate
import matplotlib.pyplot as plt
import matplotlib.patches as patches

def rectangles_methode(exp, a, b, m, l):                    #Déclaration de la fonction rectangles_methode ayant comme paramètres :
                                                        #l'expression de la fonction entrée par l'utilisateur, les bornes et le nombre d'intervalles m
    l.acquire()
    try:
        symb = Symbol("x")                                  #Déclaration du symbole x
        funct = lambdify(symb,exp)                          #Assignation du symbole à l'expression affin de savoir que le x n'est pas une variable
        borne_a = a                                         #borne_a est plus compréhenssible que a
        borne_b = b                                         #borne_b est plus compréhenssible que b

        print("Calcul par méthode des rectangles:")
        print('borne a :\t',borne_a)                        #Affichage de la borne a
        print('borne b :\t',borne_b)                        #Affichage de la borne b

    #calcul de la largeur des rectangles
    largeur = (borne_b - borne_a)/(m)                   #La largeur des rectangles des sous-intervalles est donnée par la largeur du grand intervalle
                                                        #divisée par le nombre de sous-intervalles 
    #calcul de la hauteur des rectangles
    tab_hauteurs = np.arange(m)                         #Afin de minimiser les for, j'utilise des tableau en numpy pour calculer les hauteurs des rectangles
    tab_multi = np.arange(m) 
    tab_hauteurs = funct(borne_a + (tab_multi*largeur)) #La hauteur est donnée par la valeur de la fonction en (borne_a + (n*largeur)) il est important
                                                        #de préciser la borne_a car l'utilisateur peut entrer une borne inférieure différente de 0. De cette
                                                        #manière, je commence à caculer mes hauters à partir le borne iférieure désignée

    #calcul de l'intégrale
    integrale = (tab_hauteurs * largeur)                #Calcul des surface des chaque rectangle en multipliant chaque indice du tableau par la largeur.
                                                        #De cette manière j'effectue bien l'aire d'un rectangle donnée par : longueur * largeur.
    total = 0                                           #initialisation de la variable total à 0
    total = integrale.sum(axis = 0)                     #Calcul de l'intégrale comme la somme des surfaces des rectangles sous la courbe
    print('intégrale :\t',total)                        #Affichage de la valeur de l'intégrale


    #calcul de l'erreur
    erreur = 0                                          #Initialisation de la variable erreur à 0
    grand_intervalle = (borne_b - borne_a)              #Calcul du grand intervalle afin d'alléger la formule finale

        # Calcul du maximum sur la dérivée première
        derivExp = derivate(exp,1)                          # Obtention de la dérivée 1ère de la fonction
        deriv = lambdify(symb,derivExp)                     # Définition de la dérivée 1ère
        xl = np.linspace(borne_a,borne_b,100)               # Intervalles sur lesquels le maximum va être déterminé
        ymax = np.amax(abs(deriv(xl)))                      # Maximum de la dérivée 1ère

    #val_abs_max_of_prime_derivation = abs(max_of_prime_derivation)
    erreur = ((np.power(grand_intervalle,2))/(2 * m)) * ymax    #Calcul de l'erreur à l'aide de la formule finale
    print('erreur :\t',erreur)                                  #affichage de l'erreur
    
    print('la valeur approchée est de : \t',total + erreur, 'et\t', total - erreur)     #Calcul et affichage de l'intégrale 
                                                                                        #approchée en additionnant et en soustrayant l'erreur

        abssisses = np.linspace(borne_a,borne_b,100)        #plage de valeurs sur laquelle représenter le graphique
        plt.title("Méthode rectangles")                   #titre du graphique
        plt.plot(abssisses,funct(abssisses), 'red')         #affichage de la fonction entrée par l'utilisateur sur la plage calculée ci-dessus

        #affichage des rectangles
        axes = plt.gca()                                    #récupération des données affichées sur le plot
        for i in range(m):                                  #boucle affin d'afficher les rectangles un à un
            origine_x_rect = (borne_a + (i*largeur))        #Coordonnée en abssisse du coin inférieur gauche des rectangles
            hauteur_rect = (funct(borne_a + (i*largeur)))   #Hauteur des rectangles
            axes.add_artist(patches.Rectangle((origine_x_rect, 0), largeur, hauteur_rect, edgecolor = 'black', facecolor = 'orange', fill = True, hatch = '/', linestyle = 'dashed',linewidth = 0.5, zorder = 1))
                    #Le patch rectangle permet de dessiner des rectangles à partir des coordonnées du coin inférieur gauche, de la largeur et de la longueur
                    #Il permet également de choisir le remplissage et la largeur des contours
        
    finally:
        l.release()
        plt.show()  #Affichage du plot
    
    


