from sympy import sympify
import simpson, middlepoint
import re
from multiprocessing import Process

def main():
    try:
        # Expression de la fonction sous forme de string
        strExp = input("Entrez la fonction que vous voulez intégrer (ou \"exit\" pour quitter): ")

        #Sortie du prompt
        if(strExp.lower() == "exit"):
            return 0

        if(re.search(r"e(\^|\*\*)", strExp)):
            print("Utilisez \"exp(x)\" au lieu de \"e^x\" ou \"e**x\" pour noter les exponentielles.")
            return
            
        # Expression de la fonction mathématique par Sympy
        funcExp = sympify(strExp)

        # Bornes
        a = int(input("Entrez la borne inférieure d'intégration: "))
        b = int(input("Entrez la borne supérieur d'intégration: "))
        
        # Intervalle d'intégration
        m = 0
        while (m <= 0):
            m = int(input("Entrez le nombre d'intervalle d'intégration (positif non null): "))

        # Echange des bornes si a est plus grand que b
        if(a>b): 
            print("a étant plus grand que b, les deux valeurs ont été échangées.")
            a, b = b, a

        # Liste des processus
        procs = [
            Process(target=middlepoint.middlepoint, args=(a, b, funcExp,)),
            Process(target=simpson.simpson,args=(funcExp,a,b,m,))
        ]

        # Démarrage des processus
        for p in procs:
            p.start()
        
        # Attends que chaque processus soient terminés avant de continuer
        for p in procs:
            p.join()
        

    except KeyboardInterrupt:
        print("\nInterruption, sortie du programme...")
        return 0
    except ValueError as err:
        print(f"Erreur de valeur.\t({err})")
    except KeyError as err:
        print(f"Division par zéro impossible.\t({err})")
    except Exception as err: 
        print(f"ERROR: {err}")

if __name__ == "__main__":
    code = None
    while(code is None):
        code = main()
    exit(code)
