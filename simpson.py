import numpy as np
import matplotlib.pyplot as plt
from utils.derivate import derivate
from utils.func_max import golden_search
from sympy import lambdify, sympify, abc

# Fonction de calcul d'intégral par la méthode de Simpson
# f : fonction "Sympify" à intégrer
# a : borne d'intégration inférieure
# b : borne d'intégration supérieure
# n : nombre de sous-intervalles d'intégration
def simpson(exp,a,b,n):
    # Définiton fonction
    x = abc.x
    f = lambdify(x,exp)
    
    # Définiton des 3 points de Simpson
    x1 = (a+b)/2
    
    f0 = f(a)
    f1 = f(x1)
    f2 = f(b)
    
    # Calcul de l'intégrale approchée
    i = (b-a)*(f0+4*f1+f2)/6
    
    # Calcul de l'erreur
    derivExp = derivate(exp,4) # Obtention de la dérivée 4ème de la fonction
    deriv = lambdify(x,derivExp) # Définition de la dérivée 4ème
    xl = np.linspace(a,b,100) # Intervalles sur lesquels le maximum va être déterminé
    yderiv = np.amax(deriv(xl)) # Maximum de la dérivée 4ème
    err = (-1)*(yderiv/90)*((b-a)/2)**5
    p =  lambdify(x,2*(f2 - 2*f1 + f0)*(x-x1)**2/(b-a)**2 + (f2-f0)*(x-x1)/(b-a) + f1)

    y = f(xl)
    yp = p(xl)
    if(exp.is_constant()): # Correction du problème de dimension en cas d'expression constante
        y = np.full(xl.shape, f(xl))
        yp = np.full(xl.shape, p(xl))
    
    # Représentation graphique
    
    # Fonction de base
    plt.plot(xl, y, color='black')
    plt.axhline(y = 0, color='black')
    
    # 3 points
    plt.plot(a,f0,'o',color = 'black')
    plt.annotate('f0',xy=(a,f0))
         
    plt.plot(x1,f1,'o',color = 'black')
    plt.annotate('f1',xy=(x1,f1))
    
    plt.plot(b,f2,'o',color = 'black')
    plt.annotate('f2',xy=(b,f2))
    
    # Parabole
    plt.plot(xl,yp,'--',color = 'black')
    plt.fill_between(xl,p(xl),color='gray',alpha=0.5)
    
    plt.grid()
    plt.show()
    
    print(f'Valeur de l\'intégrale approchée : {i} +/- {err}')
    
if __name__ == "__main__":
    #test de la fonction avec cos(x)
    simpson(sympify("cos(x)"),0,10,1)
