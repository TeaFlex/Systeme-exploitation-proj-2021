import numpy as np
import matplotlib.pyplot as plt
from utils.derivate import derivate
from sympy import lambdify, Symbol

#def get_tangent()

# Fonction d'affichage d'un pont sur le graphe
# x : Valeur d'abscisse
# f : Valeur d'ordonnée
# n : Indice du point recherché
def plot_point(x,f,n):
    plt.plot(x,f,'ko')
    if (n%2 == 0): # Ligne droite si indice pair
        plt.plot([x,x],[0,f],'k')
    else: # Ligne pointillée si indice impair
        plt.plot([x,x],[0,f],'k:')
    plt.annotate(f'f{n}',xy=(x,f)) # Affichage du numéro du point
    plt.annotate(f'x{n}',xy=(x,0)) # Affichage du numéro de l'abscisse du point


# Calcul d'intégrale par la méthode de Simpson composite
# exp : Fonction "Sympify" à intégrer
# a : Borne inférieur d'intégration
# b : Borne supérieur d'intégration
# m : Nombre d'intervalles d'intégration
def simpson(exp,a,b,m, l):
    l.acquire()
    try:
        # Initialisation
        x = Symbol("x")
        f = lambdify(x,exp)
        xl = np.linspace(a,b,100) # Intervalles sur lesquels le maximum va être déterminé
        h = np.linspace(a,b,m+1) # Séparation des bornes d'intégration en n+1 valeurs, formant n intervalles
        absc = np.array([]) # Ensemble des abscisses des points utilisés

        # Représentation graphique et calcul de l'erreur
        for k in range(0,m): # 3 Points sur chaque intervalle
            # Définiton des 3 points de Simpson
            x0 = h[k]
            f0 = f(x0)
            
            x1 = (h[k]+h[k+1])/2
            f1 = f(x1)
            
            x2 = h[k+1]
            f2 = f(x2)
            
            # Représentation graphique 3 points
            plot_point(x0,f0,2*k)
            plot_point(x1,f1,1+(2*k))
            plot_point(x2,f2,2*(k+1))
            
            # Représentation de la parabole passant par les 3 points
            p =  lambdify(x,2*(f2 - 2*f1 + f0)*np.power(x-x1,2)/np.power(x2-x0,2) + (f2-f0)*(x-x1)/(x2-x0) + f1) # Création de la parabole
            xp = np.linspace(x0,x2,100) # Parabole uniquement définies sur les 3 points de Simpson
            plt.plot(xp,p(xp),'--',color = 'black') # Représentation de la parabole
            plt.fill_between(xp,p(xp),color='gray',alpha=0.5) # Remplissage de la surface sous la courbe
            
            absc = np.insert(absc,absc.size,(x0,x1,x2)) # Sauvegarde des abscisses des poitns utilisés   
            

        # Calcul de l'erreur
        derivExp = derivate(exp,4) # Obtention de la dérivée 4ème de la fonction
        deriv = lambdify(x,derivExp) # Définition de la dérivée 4ème
        xl = np.linspace(a,b,100) # Intervalles sur lesquels le maximum va être déterminé
        yderiv = np.amax(deriv(xl)) # Maximum de la dérivée 4ème
        err = np.power(yderiv*(b-a),5)/np.power(180*(2*m),4) # Calcul de l'erreur et ajout à l'erreur totale

        # Calcul de l'intégrale approchée 
        absc = np.unique(absc) # Tri des abscisses enregistrées pour ne garder qu'une fois chaque valeur
        i = 0 # initialisation de la valeur de l'intégrale approchée
        for t in range(1,absc.size-1): # Pour chaque point sauf le premier et le dernier
            if (t%2 == 0): # S'il s'agit d'un point pair
                i += 2*f(absc[t])
            else: # S'il s'agit d'un point impair
                i += 4*f(absc[t])
        i += f(absc[0]) + f(absc[-1]) # Ajout de la valeur du premier et dernier point
        i *= (b-a)/(3*2*m)

        print(f'Valeur de l\'intégrale approchée de Simpson : {i} +/- {abs(err)}\n')

        # Représentation graphique
        plt.title("Méthode Simpson") # Titre du graphique
        plt.plot(xl,f(xl),'k') # Affichage fonction à intégrer
        plt.axhline(y = 0,color='black') # Affiche axe des abscisses
        plt.ylim([11/10*np.amin(f(xl)),11/10*np.amax(f(xl))]) # Limite en ordonnées : 10% par rapport au maxium positif et négatif de la fonction à intégrer

        plt.grid() # Affichage de la grille
        
    finally:
        l.release()
        plt.show() # Affichage du graphe
